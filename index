import dotenv from "dotenv";
dotenv.config({ override: true });

import express from "express";
import axios from "axios";
import fs from "fs";
import path from "path";
import crypto from "crypto";
import OpenAI, { toFile } from "openai";

/* ================== APP ================== */
const app = express();
app.use(
  express.json({
    limit: "2mb",
    verify: (req, _res, buf) => {
      req.rawBody = buf.toString();
    },
  })
);
app.use(express.urlencoded({ extended: true, limit: "2mb" }));

/* ================== CONFIG ================== */
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;

const ZAPI_INSTANCE = process.env.ZAPI_INSTANCE;
const ZAPI_TOKEN = process.env.ZAPI_TOKEN;
const ZAPI_CLIENT_TOKEN = process.env.ZAPI_CLIENT_TOKEN;

const SHOPIFY_DOMAIN = process.env.SHOPIFY_DOMAIN;
const SHOPIFY_STOREFRONT_TOKEN = process.env.SHOPIFY_STOREFRONT_TOKEN;
const SHOPIFY_API_VERSION = process.env.SHOPIFY_API_VERSION || "2024-10";
const SHOP_PUBLIC_DOMAIN = (process.env.SHOP_PUBLIC_DOMAIN || "https://3dfans.com.br").replace(/\/+$/, "");

const APPMAX_LINK_16 = (process.env.APPMAX_LINK_16 || "").trim();
const APPMAX_LINK_21 = (process.env.APPMAX_LINK_21 || "").trim();

const APPMAX_BASE_URL = (process.env.APPMAX_BASE_URL || "https://admin.appmax.com.br/api/v3").replace(/\/+$/, "");
const APPMAX_ACCESS_TOKEN = (process.env.APPMAX_ACCESS_TOKEN || "").trim();

const PORT = Number(process.env.PORT || 3000);

/** Pr√©via (taxa) */
const PREVIEW_FEE_BRL = "R$9,90";
const PREVIEW_FEE_AMOUNT = 9.9;

/** Debug */
const DEBUG = String(process.env.DEBUG || "").toLowerCase() === "true";

/** Admin phones para ensinar (ex: "5511999999999,5511988887777") */
const ADMIN_PHONES = new Set(
  String(process.env.ADMIN_PHONES || "")
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean)
);

console.log("ENV CHECK:", {
  OPENAI_API_KEY: !!OPENAI_API_KEY,
  ZAPI_INSTANCE: !!ZAPI_INSTANCE,
  ZAPI_TOKEN: !!ZAPI_TOKEN,
  ZAPI_CLIENT_TOKEN: !!ZAPI_CLIENT_TOKEN,
  SHOPIFY_DOMAIN: !!SHOPIFY_DOMAIN,
  SHOPIFY_STOREFRONT_TOKEN: !!SHOPIFY_STOREFRONT_TOKEN,
  SHOP_PUBLIC_DOMAIN,
  APPMAX_LINK_16: !!APPMAX_LINK_16,
  APPMAX_LINK_21: !!APPMAX_LINK_21,
  APPMAX_BASE_URL,
  APPMAX_ACCESS_TOKEN: !!APPMAX_ACCESS_TOKEN,
  ADMIN_PHONES: ADMIN_PHONES.size,
  DEBUG,
});

const openai = new OpenAI({ apiKey: OPENAI_API_KEY });

/* ================== LOG GLOBAL (DEBUG) ================== */
if (DEBUG) {
  app.use((req, _res, next) => {
    console.log("‚û°Ô∏è IN:", req.method, req.url);
    next();
  });
}

/* ================== PROMPTS EXTERNOS ================== */
const PROMPTS_DIR = path.resolve(process.cwd(), "prompts");
const SYSTEM_TXT_PATH = path.join(PROMPTS_DIR, "system.txt");
const REPLIES_JSON_PATH = path.join(PROMPTS_DIR, "replies.json");

let SYSTEM_PROMPT = "";
let REPLIES = {};

const FALLBACK_SYSTEM = `Voc√™ √© o atendente da 3DFANS no WhatsApp.`;
const FALLBACK_REPLIES = {
  welcome:
    "Ol√°! üòä O que voc√™ procura hoje?\n\n1Ô∏è‚É£ Mascotes de time de futebol\n2Ô∏è‚É£ Miniaturas personalizadas\n\nResponda com 1 ou 2.",
  menuMascote:
    "Show! ‚öΩ Temos mascotes 10cm, 16cm e 21cm.\nüì∏ As fotos s√£o reais do produto.\nMe diga qual time voc√™ quer.",
  menuMiniatura:
    "Perfeito üòä Conte-me o que voc√™ quer transformar em miniatura.\nüì∏ Envie a foto por aqui mesmo.\nTamanhos: 16cm ou 21cm.",
  prazoMiniatura: "Levamos at√© 7 dias √∫teis para produzir, pintar e embalar para envio.",
};

function loadPrompts() {
  try {
    SYSTEM_PROMPT = fs.readFileSync(SYSTEM_TXT_PATH, "utf8").trim() || FALLBACK_SYSTEM;
  } catch {
    SYSTEM_PROMPT = FALLBACK_SYSTEM;
  }

  try {
    const json = JSON.parse(fs.readFileSync(REPLIES_JSON_PATH, "utf8"));
    REPLIES = Object.keys(json).length ? json : FALLBACK_REPLIES;
  } catch {
    REPLIES = FALLBACK_REPLIES;
  }
}
loadPrompts();
try {
  fs.watch(PROMPTS_DIR, () => loadPrompts());
} catch {}

/* ================== UTILS ================== */
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

function onlyDigits(v) {
  return String(v || "").replace(/\D/g, "");
}

function normalize(t) {
  return String(t || "").toLowerCase().trim();
}

/* ================== Z-API ================== */
function zapiHeaders() {
  return {
    "client-token": ZAPI_CLIENT_TOKEN,
    "Client-Token": ZAPI_CLIENT_TOKEN,
    "Content-Type": "application/json",
  };
}

async function simulateTyping(phone) {
  const delay = 500 + Math.random() * 1000;
  try {
    await axios.post(
      `https://api.z-api.io/instances/${ZAPI_INSTANCE}/token/${ZAPI_TOKEN}/send-presence`,
      { phone, presence: "composing" },
      { headers: zapiHeaders(), timeout: 10000 }
    );
  } catch {}
  await sleep(delay);
}

async function zapiSendText(phone, message) {
  await simulateTyping(phone);
  try {
    const r = await axios.post(
      `https://api.z-api.io/instances/${ZAPI_INSTANCE}/token/${ZAPI_TOKEN}/send-text`,
      { phone, message },
      { headers: zapiHeaders(), timeout: 20000 }
    );
    if (DEBUG) console.log("‚úÖ ZAPI text sent:", { phone, status: r.status });
    return r;
  } catch (e) {
    console.log("‚ùå zapiSendText:", e?.response?.status, e?.response?.data || e?.message);
    throw e;
  }
}

async function zapiSendImage(phone, image, caption) {
  await simulateTyping(phone);
  try {
    const r = await axios.post(
      `https://api.z-api.io/instances/${ZAPI_INSTANCE}/token/${ZAPI_TOKEN}/send-image`,
      { phone, image, caption },
      { headers: zapiHeaders(), timeout: 45000 }
    );
    if (DEBUG) console.log("‚úÖ ZAPI image sent:", { phone, status: r.status });
    return r;
  } catch (e) {
    console.log("‚ùå zapiSendImage:", e?.response?.status, e?.response?.data || e?.message);
    throw e;
  }
}

async function sendLoadingStep(phone, text, delay = 1200) {
  await zapiSendText(phone, text);
  await sleep(delay);
}

/* ================== ANTI DUPLICA√á√ÉO ================== */
const recentIncoming = new Map();
function isDuplicate(phone, text) {
  const key = `${phone}:${text}`;
  const now = Date.now();
  if (recentIncoming.has(key) && now - recentIncoming.get(key) < 8000) return true;
  recentIncoming.set(key, now);
  return false;
}

/* ================== PARSE PAYLOAD Z-API (ROBUSTO) ================== */
function extractPhone(body) {
  return (
    body?.phone ||
    body?.from ||
    body?.text?.from ||
    body?.sender ||
    body?.chatId ||
    body?.message?.from ||
    body?.data?.phone ||
    body?.data?.from ||
    null
  );
}

function extractText(body) {
  const v =
    body?.message ??
    body?.text?.message ??
    body?.text?.text ??
    body?.text ??
    body?.data?.message ??
    body?.data?.text?.message ??
    body?.data?.text ??
    "";

  if (typeof v === "string") return v;
  if (typeof v?.message === "string") return v.message;
  return "";
}

function extractImageUrl(body) {
  const candidates = [
    body?.image?.imageUrl,
    body?.image?.url,
    body?.imageUrl,

    body?.message?.image?.imageUrl,
    body?.message?.imageUrl,
    body?.message?.media?.url,
    body?.message?.mediaUrl,

    body?.media?.url,
    body?.mediaUrl,

    body?.data?.image?.imageUrl,
    body?.data?.media?.url,
    body?.data?.mediaUrl,
  ].filter((v) => typeof v === "string" && v.startsWith("http"));

  return candidates[0] || null;
}

function hasImage(body) {
  return !!extractImageUrl(body);
}

function isMenuCommand(t) {
  return ["menu", "voltar", "inicio", "in√≠cio", "come√ßar", "comecar"].includes(t);
}

function isHumanCommand(t) {
  return (
    t.includes("humano") ||
    t.includes("atendente") ||
    t.includes("falar com atendente") ||
    t.includes("falar com alguem") ||
    t.includes("falar com algu√©m")
  );
}

function detectMiniSize(t) {
  if (/\b(16|16cm|16 cm)\b/.test(t)) return "16cm";
  if (/\b(21|21cm|21 cm)\b/.test(t)) return "21cm";
  return null;
}

/* ================== APRENDIZADO (MEM√ìRIA) ================== */
const DATA_DIR = path.resolve(process.cwd(), "data");
const MEMORY_PATH = path.join(DATA_DIR, "memory.json");

function ensureDataDir() {
  try {
    fs.mkdirSync(DATA_DIR, { recursive: true });
  } catch {}
}

function loadMemory() {
  ensureDataDir();
  try {
    const raw = fs.readFileSync(MEMORY_PATH, "utf8");
    const json = JSON.parse(raw);
    if (json && typeof json === "object") return json;
  } catch {}
  return { global: {} };
}

function saveMemory(mem) {
  ensureDataDir();
  fs.writeFileSync(MEMORY_PATH, JSON.stringify(mem, null, 2), "utf8");
}

let MEMORY = loadMemory();

function teachParse(tRaw) {
  const s = String(tRaw || "").trim();
  let rest = s;
  if (rest.toLowerCase().startsWith("ensinar:")) rest = rest.slice(8).trim();
  else if (rest.toLowerCase().startsWith("ensinar")) rest = rest.slice(7).trim();
  else if (rest.toLowerCase().startsWith("aprenda:")) rest = rest.slice(7).trim();
  else if (rest.toLowerCase().startsWith("aprenda")) rest = rest.slice(6).trim();

  const m = rest.match(/^(.*?)(?:=|=>|->)(.*)$/);
  if (!m) return null;

  const q = normalize(m[1]);
  const a = String(m[2] || "").trim();
  if (!q || !a) return null;

  return { q, a };
}

function memoryGetAnswer(qNorm) {
  return MEMORY?.global?.[qNorm] || null;
}

function memorySetAnswer(qNorm, answer) {
  MEMORY.global = MEMORY.global || {};
  MEMORY.global[qNorm] = answer;
  saveMemory(MEMORY);
}

/* ================== OR√áAMENTO (S√ì AP√ìS PR√âVIA) ================== */
function buildBudget(size) {
  const price = size === "16cm" ? "R$399" : "R$699";
  const link = size === "16cm" ? APPMAX_LINK_16 : APPMAX_LINK_21;

  const linkLine = link
    ? `üëâ Link de pagamento (AppMax): ${link}\n\n`
    : "üëâ Link de pagamento: vou te enviar j√° j√° por aqui.\n\n";

  return (
    "Perfeito! üòä Segue o or√ßamento da sua miniatura personalizada:\n\n" +
    `üìè Tamanho: ${size}\n` +
    `üí∞ Valor: ${price}\n` +
    "‚è±Ô∏è Prazo: at√© 7 dias √∫teis\n" +
    "üöö Frete: Gr√°tis\n\n" +
    linkLine +
    "Assim que o pagamento for confirmado, iniciamos a produ√ß√£o."
  );
}

function buildPreviewPaymentRequest(pixEmv) {
  return (
    "üì∏ Foto recebida! üòä\n\n" +
    "Para criar a *PR√âVIA* da sua miniatura, h√° uma taxa de *R$9,90*.\n\n" +
    "üí≥ *PIX Copia e Cola:*\n" +
    "```" + pixEmv + "```\n\n" +
    "‚è±Ô∏è Ap√≥s o pagamento, a confirma√ß√£o √© autom√°tica e a pr√©via √© gerada em seguida. üíõ"
  );
}

/* ================== SHOPIFY (BUSCA PRODUTOS) ================== */
async function shopifySearchProducts(term) {
  if (!SHOPIFY_DOMAIN || !SHOPIFY_STOREFRONT_TOKEN) return [];

  const query = `
    query ($q: String!) {
      search(query: $q, first: 6, types: [PRODUCT]) {
        edges {
          node {
            ... on Product {
              title
              handle
              tags
              featuredImage { url }
              priceRange { minVariantPrice { amount currencyCode } }
            }
          }
        }
      }
    }
  `;

  const res = await axios.post(
    `https://${SHOPIFY_DOMAIN}/api/${SHOPIFY_API_VERSION}/graphql.json`,
    { query, variables: { q: term } },
    {
      headers: {
        "X-Shopify-Storefront-Access-Token": SHOPIFY_STOREFRONT_TOKEN,
        "Content-Type": "application/json",
      },
      timeout: 25000,
    }
  );

  const edges = res.data?.data?.search?.edges || [];
  return edges.map((e) => ({
    title: e.node.title,
    image: e.node.featuredImage?.url || null,
    priceAmount: e.node.priceRange?.minVariantPrice?.amount || null,
    currency: e.node.priceRange?.minVariantPrice?.currencyCode || null,
    url: `${SHOP_PUBLIC_DOMAIN}/products/${e.node.handle}`,
    tags: e.node.tags || [],
  }));
}

/* ================== GPT IMAGE: gerar estatueta ================== */
async function generateStatueFromImageUrl(imageUrl) {
  const resp = await axios.get(imageUrl, {
    responseType: "arraybuffer",
    timeout: 45000,
  });

  const buf = Buffer.from(resp.data);
  const file = await toFile(buf, "input.jpg", { type: "image/jpeg" });

  const rsp = await openai.images.edit({
    model: "gpt-image-1",
    image: [file],
    prompt:
      "Crie uma estatueta colecion√°vel 3D baseada EXATAMENTE na imagem enviada. " +
      "Estilo realista premium (produto f√≠sico), impress√£o 3D pintada √† m√£o, " +
      "ilumina√ß√£o profissional de est√∫dio, fundo neutro, base redonda preta elegante. " +
      "N√£o mude as caracter√≠sticas principais do rosto/identidade. Foque em apar√™ncia de produto.",
    size: "1024x1024",
    quality: "high",
    input_fidelity: "high",
  });

  const b64 = rsp?.data?.[0]?.b64_json;
  if (!b64) throw new Error("OpenAI n√£o retornou b64_json");
  return `data:image/png;base64,${b64}`;
}

/* ================== REF PERSIST√äNCIA (CR√çTICO) ================== */
const REFS_PATH = path.join(DATA_DIR, "refs.json");

function loadRefs() {
  ensureDataDir();
  try {
    const raw = fs.readFileSync(REFS_PATH, "utf8");
    const j = JSON.parse(raw);
    return {
      refToPhone: j?.refToPhone || {},
      phoneToRef: j?.phoneToRef || {},
    };
  } catch {
    return { refToPhone: {}, phoneToRef: {} };
  }
}

function saveRefs(refToPhoneObj, phoneToRefObj) {
  ensureDataDir();
  fs.writeFileSync(
    REFS_PATH,
    JSON.stringify({ refToPhone: refToPhoneObj, phoneToRef: phoneToRefObj }, null, 2),
    "utf8"
  );
}

/* ================== ESTADO DO CLIENTE ================== */
const greeted = new Set();
const processingPreview = new Set();
const clientState = new Map();

/** ref -> phone e phone -> ref (AGORA PERSISTIDOS) */
const refsDisk = loadRefs();
const refToPhoneObj = refsDisk.refToPhone;
const phoneToRefObj = refsDisk.phoneToRef;

function getState(phone) {
  return (
    clientState.get(phone) || {
      mode: null,
      photoReceived: false,

      lastImageUrl: null,
      cpf: null,
      previewPixLink: null,
      previewPaymentPending: false,
      previewPaid: false,
      previewSent: false,

      miniSize: null,
      humanHandoff: false,

      lastPaymentReminderAt: 0,
    }
  );
}

function setState(phone, patch) {
  clientState.set(phone, { ...getState(phone), ...patch });
}

function createOrGetRefForPhone(phone) {
  const existing = phoneToRefObj[phone];
  if (existing) return existing;

  const ref = crypto.randomBytes(8).toString("hex");
  phoneToRefObj[phone] = ref;
  refToPhoneObj[ref] = phone;
  saveRefs(refToPhoneObj, phoneToRefObj);

  return ref;
}

/* ================== APPMAX API v3 ================== */
async function appmaxPost(endpoint, payload) {
  if (!APPMAX_ACCESS_TOKEN) throw new Error("APPMAX_ACCESS_TOKEN ausente no .env");
  const url = `${APPMAX_BASE_URL}${endpoint}`;
  const body = { "access-token": APPMAX_ACCESS_TOKEN, ...payload };
  const r = await axios.post(url, body, {
    headers: { "Content-Type": "application/json" },
    timeout: 30000,
  });
  return r.data;
}

async function createPreviewOrderAppmax({ phone, cpf }) {
  const ref = createOrGetRefForPhone(phone);
  const tel11 = onlyDigits(phone).replace(/^55/, "");

  const customer = await appmaxPost("/customer", {
    firstname: "Cliente",
    lastname: "3DFANS",
    email: `${tel11}@3dfans.com.br`,
    telephone: tel11,
    document_number: onlyDigits(cpf),
    custom_txt: `3DFANS_PREVIA ref=${ref}`,
    tracking: {
      utm_source: "whatsapp",
      utm_medium: "bot",
      utm_campaign: "previa_3dfans",
      utm_content: `ref=${ref}`,
    },
  });

  const customer_id = customer?.data?.id || customer?.id;
  if (!customer_id) {
    console.log("‚ùå APPMAX CUSTOMER RAW:", JSON.stringify(customer, null, 2));
    throw new Error("customer_id n√£o retornado");
  }

  const order = await appmaxPost("/order", {
    customer_id,
    external_id: ref,
    products: [
      {
        sku: "PREVIA-3DFANS",
        name: "Taxa de Pr√©via 3DFANS",
        qty: 1,
        price: PREVIEW_FEE_AMOUNT,
        digital_product: 1,
      },
    ],
    shipping: 0,
    discount: 0,
  });

  const order_id = order?.data?.id || order?.id;
  if (!order_id) {
    console.log("‚ùå APPMAX ORDER RAW:", JSON.stringify(order, null, 2));
    throw new Error("order_id n√£o retornado");
  }

  const expiration_date = new Date(Date.now() + 30 * 60 * 1000)
    .toISOString()
    .slice(0, 19)
    .replace("T", " ");

  const pix = await appmaxPost("/payment/pix", {
    cart: { order_id },
    customer: { customer_id },
    payment: {
      pix: {
        document_number: onlyDigits(cpf),
        expiration_date,
      },
    },
  });

  const payLink =
  pix?.data?.pix?.pix_emv ||
  pix?.pix_emv ||
  null;

  

  if (DEBUG) console.log("üßæ APPMAX PIX RAW:", JSON.stringify(pix, null, 2));

  return {
  ref,
  customer_id,
  order_id,
  payLink // <-- agora √© o PIX COPIA E COLA
};
}

/* ================== FUN√á√ÉO: GERAR PR√âVIA ================== */
async function runPreviewFlow(phone) {
  const st = getState(phone);

  if (!st.lastImageUrl) {
    await zapiSendText(phone, "N√£o encontrei sua foto aqui üòï Pode reenviar a imagem?");
    return;
  }

  if (!st.previewPaid) {
    if (st.previewPixLink) {
      await zapiSendText(phone, buildPreviewPaymentRequest(st.previewPixLink));
      return;
    }
    await zapiSendText(
      phone,
      "Para gerar a PR√âVIA, preciso confirmar a taxa de R$9,90 via PIX.\n" +
        "üëâ Me envie seu *CPF (somente n√∫meros)* para eu gerar o PIX automaticamente."
    );
    return;
  }

  if (processingPreview.has(phone)) {
    await zapiSendText(phone, "J√° estou gerando sua pr√©via üòä S√≥ um instante‚Ä¶");
    return;
  }

  processingPreview.add(phone);
  try {
    await sendLoadingStep(phone, "IA: Analisando a foto‚Ä¶ 25%");
    await sendLoadingStep(phone, "IA: Modelando a miniatura em 3D‚Ä¶ 55%");
    await sendLoadingStep(phone, "IA: Aplicando acabamento e pintura‚Ä¶ 83%");

    const generatedDataUri = await generateStatueFromImageUrl(st.lastImageUrl);

    await zapiSendImage(
      phone,
      generatedDataUri,
      "‚ú® Aqui est√° a PR√âVIA da sua estatueta!\n\nAgora escolha o tamanho para liberar o pagamento:\nüëâ 16cm ou 21cm"
    );

    setState(phone, { previewSent: true });
  } catch (e) {
    const msg = String(e?.response?.data?.error?.message || e?.message || "");
    console.log("‚ùå Erro ao gerar pr√©via:", e?.response?.status, e?.response?.data || e?.message);

    if (String(e?.response?.status) === "403" && msg.toLowerCase().includes("verified")) {
      await zapiSendText(
        phone,
        "‚ö†Ô∏è No momento, o gerador de pr√©vias est√° em configura√ß√£o interna.\n" +
          "Digite *humano* que um atendente continua com voc√™."
      );
      setState(phone, { humanHandoff: true });
      return;
    }

    await zapiSendText(
      phone,
      "‚ùå Deu um erro ao gerar a pr√©via.\nPode reenviar a foto? Se preferir, digite *humano*."
    );
  } finally {
    processingPreview.delete(phone);
  }
}

/* ================== WEBHOOK APPMAX (√öNICO) ================== */
app.post("/webhook-appmax", async (req, res) => {
  try {
    const event = req.body?.event;
    const status = String(req.body?.data?.status || "").toLowerCase();

    if (DEBUG) {
      console.log("‚úÖ APPMAX HIT");
      console.log("EVENT:", event);
      console.log("STATUS:", status);
      console.log("BODY:", JSON.stringify(req.body, null, 2));
    }

    const isPaid = event === "OrderApproved" && status === "aprovado";
    if (!isPaid) return res.sendStatus(200);

    const ref = req.body?.data?.external_id || req.body?.external_id || null;
    const phone = ref ? refToPhoneObj[ref] : null;

    console.log("üí∞ APPMAX aprovado:", { ref: ref || "MISSING", phone: phone ? "OK" : "MISSING" });

    if (!phone) return res.sendStatus(200);

    setState(phone, { previewPaid: true, previewPaymentPending: false });

    res.sendStatus(200);

    setImmediate(async () => {
      try {
        await zapiSendText(phone, "‚úÖ Pagamento confirmado! Vou gerar sua PR√âVIA agora üòäüé®");
        await runPreviewFlow(phone);
      } catch (e) {
        console.log("‚ùå erro p√≥s-pagamento:", e?.message);
      }
    });
  } catch (err) {
    console.error("‚ùå ERRO APPMAX", err?.response?.data || err?.message || err);
    return res.sendStatus(200);
  }
});

/* ================== WEBHOOK: MENSAGENS WHATSAPP (Z-API) ================== */
app.post("/webhook", async (req, res) => {
  try {
    if (DEBUG) {
      console.log("‚úÖ /webhook HIT");
      console.log(JSON.stringify(req.body, null, 2));
    }

    const phone = extractPhone(req.body);
    const text = extractText(req.body);

    if (!phone) {
      console.log("‚ö†Ô∏è Webhook sem phone. Chaves:", Object.keys(req.body || {}));
      return res.sendStatus(200);
    }

    if (isDuplicate(phone, text)) return res.sendStatus(200);

    const t = normalize(text);
    const state = getState(phone);

    /* ================== ENSINAR (ADMIN) ================== */
    if (t.startsWith("ensinar") || t.startsWith("aprenda")) {
      if (!ADMIN_PHONES.size || !ADMIN_PHONES.has(phone)) {
        await zapiSendText(phone, "‚ö†Ô∏è Apenas administradores podem usar o comando *ensinar*.");
        return res.sendStatus(200);
      }

      const parsed = teachParse(text);
      if (!parsed) {
        await zapiSendText(
          phone,
          "Formato inv√°lido.\nUse: *ensinar: pergunta = resposta*\nEx:\nensinar: qual o prazo? = At√© 7 dias √∫teis."
        );
        return res.sendStatus(200);
      }

      memorySetAnswer(parsed.q, parsed.a);
      await zapiSendText(phone, `‚úÖ Aprendi!\n\nPergunta: "${parsed.q}"\nResposta: "${parsed.a}"`);
      return res.sendStatus(200);
    }

    /* ================== RESPONDER DA MEM√ìRIA ================== */
    if (t) {
      const memAns = memoryGetAnswer(t);
      if (memAns) {
        await zapiSendText(phone, memAns);
        return res.sendStatus(200);
      }
    }

    /* üë®‚Äçüíº HUMANO */
    if (isHumanCommand(t)) {
      setState(phone, { humanHandoff: true });
      await zapiSendText(
        phone,
        "Perfeito üòä Vou te colocar em atendimento humano agora.\nUm atendente vai continuar com voc√™ por aqui."
      );
      return res.sendStatus(200);
    }

    /* ‚õî BLOQUEIA BOT SE HUMANO */
    if (state.humanHandoff) return res.sendStatus(200);

    /* üîÑ MENU */
    if (isMenuCommand(t)) {
      setState(phone, {
        mode: null,
        photoReceived: false,
        lastImageUrl: null,
        cpf: null,
        previewPixLink: null,
        previewPaymentPending: false,
        previewPaid: false,
        previewSent: false,
        miniSize: null,
        humanHandoff: false,
        lastPaymentReminderAt: 0,
      });
      greeted.add(phone);
      await zapiSendText(phone, REPLIES.welcome || FALLBACK_REPLIES.welcome);
      return res.sendStatus(200);
    }

    /* üì∏ FOTO -> pede CPF e trava at√© pagar */
    if (hasImage(req.body)) {
      greeted.add(phone);

      const imageUrl = extractImageUrl(req.body);
      if (!imageUrl) {
        await zapiSendText(phone, "N√£o consegui acessar sua imagem üòï Pode reenviar a foto por aqui?");
        return res.sendStatus(200);
      }

      setState(phone, {
        mode: "miniatura",
        photoReceived: true,
        lastImageUrl: imageUrl,
        cpf: null,
        previewPixLink: null,
        previewPaymentPending: true,
        previewPaid: false,
        previewSent: false,
        miniSize: null,
      });

      await zapiSendText(
        phone,
        "üì∏ Foto recebida! üòä\n\n" +
          "Para gerar a *PR√âVIA* tem uma taxa de *R$9,90* via PIX.\n" +
          "üëâ Me envie seu *CPF (somente n√∫meros)* para eu gerar o PIX automaticamente."
      );
      return res.sendStatus(200);
    }

    /* üëã PRIMEIRO CONTATO */
    if (!greeted.has(phone)) {
      greeted.add(phone);
      await zapiSendText(phone, REPLIES.welcome || FALLBACK_REPLIES.welcome);
      return res.sendStatus(200);
    }

    /* üì¶ ESCOLHA MENU */
    if (t === "1") {
      setState(phone, { mode: "mascote" });
      await zapiSendText(phone, REPLIES.menuMascote || FALLBACK_REPLIES.menuMascote);
      return res.sendStatus(200);
    }

    if (t === "2") {
      setState(phone, {
        mode: "miniatura",
        photoReceived: false,
        lastImageUrl: null,
        cpf: null,
        previewPixLink: null,
        previewPaymentPending: false,
        previewPaid: false,
        previewSent: false,
        miniSize: null,
      });
      await zapiSendText(phone, REPLIES.menuMiniatura || FALLBACK_REPLIES.menuMiniatura);
      return res.sendStatus(200);
    }

    /* üßæ CPF -> GERAR PIX (APPMAX v3) */
    if (state.mode === "miniatura" && state.previewPaymentPending && !state.previewPaid && state.lastImageUrl) {
      const cpfDigits = onlyDigits(text);

      if (cpfDigits.length === 11) {
        if (!APPMAX_ACCESS_TOKEN) {
          await zapiSendText(phone, "‚ö†Ô∏è Integra√ß√£o de pagamento ainda n√£o configurada. Digite *humano* para continuar.");
          setState(phone, { humanHandoff: true });
          return res.sendStatus(200);
        }

        if (!state.previewPixLink) {
          setState(phone, { cpf: cpfDigits });
          await zapiSendText(phone, "‚úÖ CPF recebido! Gerando o PIX agora‚Ä¶");

          try {
            const { payLink } = await createPreviewOrderAppmax({ phone, cpf: cpfDigits });

            if (payLink) {
              setState(phone, { previewPixLink: payLink });
              await zapiSendText(phone, buildPreviewPaymentRequest(payLink));
            } else {
              await zapiSendText(phone, "‚ö†Ô∏è Gereu o PIX, mas n√£o veio o link. Digite *humano*.");
              setState(phone, { humanHandoff: true });
            }
          } catch (e) {
            console.log("‚ùå Erro ao gerar PIX Appmax:", e?.response?.data || e?.message);
            await zapiSendText(phone, "‚ùå N√£o consegui gerar o PIX agora. Tente novamente em instantes.");
          }

          return res.sendStatus(200);
        }

        await zapiSendText(phone, buildPreviewPaymentRequest(state.previewPixLink));
        return res.sendStatus(200);
      }
    }

    /* üîí aguardando pagamento: lembra link sem spam */
    if (state.mode === "miniatura" && state.previewPaymentPending && !state.previewPaid && state.lastImageUrl) {
      const now = Date.now();
      if (now - (state.lastPaymentReminderAt || 0) > 60000) {
        setState(phone, { lastPaymentReminderAt: now });

        if (state.previewPixLink) {
          await zapiSendText(
            phone,
            "Estou aguardando a confirma√ß√£o do pagamento da taxa de pr√©via üòä\n\n" +
              `‚úÖ Pague aqui: ${state.previewPixLink}\n\n` +
              "Assim que confirmar, eu gero a pr√©via automaticamente."
          );
        } else {
          await zapiSendText(phone, "Para eu gerar o PIX da taxa de pr√©via (R$9,90), me envie seu *CPF (11 d√≠gitos)* üòä");
        }
      }
      return res.sendStatus(200);
    }

    /* üìè TAMANHO -> OR√áAMENTO (S√ì DEPOIS DA PR√âVIA) */
    if (state.mode === "miniatura" && state.photoReceived) {
      const size = detectMiniSize(t);

      if (size) {
        if (!state.previewSent) {
          await zapiSendText(
            phone,
            "Quase l√° üòä\nPrimeiro eu preciso te enviar a PR√âVIA (ap√≥s confirmar a taxa).\nDepois voc√™ escolhe 16cm ou 21cm para liberar o pagamento."
          );
          return res.sendStatus(200);
        }

        setState(phone, { miniSize: size });
        await zapiSendText(phone, buildBudget(size));
        return res.sendStatus(200);
      }
    }

    /* ‚öΩ MASCOTE -> BUSCAR SHOPIFY */
    if (state.mode === "mascote" && t) {
      const q = `${text} mascote`.trim();

      let products = [];
      try {
        products = await shopifySearchProducts(q);
      } catch (e) {
        console.log("‚ùå Falha Shopify:", e?.response?.status, e?.response?.data || e?.message);
      }

      if (!products.length) {
        await zapiSendText(phone, "N√£o achei esse no site agora üòï\nMe diga o nome do time (ex: Flamengo, Corinthians, CRB).");
        return res.sendStatus(200);
      }

      for (const p of products.slice(0, 3)) {
        const price = p.priceAmount ? `R$${Math.round(Number(p.priceAmount))}` : "";
        const caption = `üõí ${p.title}\n${price ? `üí∞ ${price}\n` : ""}üì∏ Foto real do produto\nüîó ${p.url}`;

        if (p.image) await zapiSendImage(phone, p.image, caption);
        else await zapiSendText(phone, caption);
      }

      return res.sendStatus(200);
    }

    /* fallback */
    if (t && state.mode === "miniatura") {
      await zapiSendText(phone, "üì∏ Para miniatura personalizada, me envie a foto por aqui üòä");
      return res.sendStatus(200);
    }

    return res.sendStatus(200);
  } catch (err) {
    console.error("ERRO /webhook:", err?.response?.status, err?.response?.data || err?.message || err);
    return res.sendStatus(200);
  }
});

/* ================== HEALTH ================== */
app.get("/", (_req, res) => res.send("OK - webhook online"));
app.get("/health", (_req, res) => res.json({ ok: true }));

app.listen(PORT, () => console.log(`üöÄ Rodando na porta ${PORT}`));
